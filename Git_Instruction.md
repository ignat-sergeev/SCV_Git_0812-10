# Работа с Git

## 1. Проверка наличия установленного Git

В терминале выполнить команду `git version`.

Если Git установлен, появится сообщение с информацией о версии программы. Иначе будет сообщение об ошибке.

## 2. Установка Git

Загружаем последнюю версию Git с сайта <https://git-scm.com/downloads>
Устанавливаем с настройками по умолчанию.

## 3. Настройка Git

При первом использовании Git необходимо представиться. Для этого в терминале необходимо выполнить команды:

```bash
git config --global user.email "your@email"
git config --global user.name "Your Name"
```

## 4. Инициализация репозитория

Для создания репозитория необходимо выполнить в терминале команду:

```bash
git init
```

Команду `git init` выполняют только один раз для первоначальной настройки нового репозитория. Выполнение команды приведет к созданию нового подкаталога `.git` в текущем рабочем каталоге. Кроме того, будет создана новая главная ветка.

Для инициализации репозитория в определённой папке необходимо создать эту папку, перейти в неё и выполнить команду инициализации:

```bash
cd /path/to/your/existing/code 
git init
```

Также можно указать папку проекта в команде инициализации:

```bash
git init <project_folder>
```

В этом случае инициализация репозитория произойдёт в указанной папке.

## 5. Запись изменений в репозиторий

### 5.1. Команда git status

Команда `git status` отображает состояние рабочего каталога и раздела проиндексированных файлов. С ее помощью можно проверить индексацию изменений и увидеть файлы, которые не отслеживаются Git.

### 5.2. Команда git add

Команда `git add` добавляет изменение из рабочего каталога в раздел проиндексированных файлов. Она сообщает Git, что мы хотим включить изменения в конкретном файле в следующий коммит.

* В рабочем каталоге создадим файл `NewFile.txt` с каким-либо текстом.
* Команда `git status` покажет, что новый файл не отслеживается Git

```bash
$ git status
On branch master
...
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        NewFile.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

* Добавим новый файл в репозиторий проиндексированных файлов

```bash
git add NewFile.txt
```

* Проверим, что файл добавлен

```bash
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   NewFile.txt
```

Команду `git add` часто используют с флагом --all. Команда `git add --all` добавляет все измененные и неотслеживаемые файлы в репозиторий и обновляет дерево изменений репозитория.

### 5.3. Команда git commit

Команда `git commit` делает для проекта снимок текущего состояния изменений, добавленных в раздел проиндексированных файлов.

Перед выполнением команды `git commit` необходимо использовать команду `git add`, чтобы добавить в проект («проиндексировать») изменения, которые будут сохранены в коммите.

Сохраним изменения из предыдущего пункта:

```bash
git commit
```

Эта команда откроет текстовый редактор для ввода комментария к коммиту и покажет список файлов, которые будут зафиксированы в этом коммите:

```bash
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
# Changes to be committed:
#       new file:   NewFile.txt
#
```

Далее необходимо ввести информативный комментарий (i - вставка текста, ESC - выход из режима редактирования) и сохранить его (:wq).

После сохранения комментария Git выведет информацию о принятых изменениях:

```diff
$ git commit
[master 480a789] Добавление файла NewFile.txt
 1 file changed, 1 insertion(+)
 create mode 100644 NewFile.txt
```

Для проведения коммита без вызова текстового редактора можно использовать команду:

```bash
git commit -m "commit message"
```

Чтобы выполнить коммит состояния со всеми изменениями в рабочем каталоге (без предварительной команды `git add`), можно использовать команду

```bash
git commit -a
```

Эта команда включает только изменения отслеживаемых файлов, которые уже были в какой-то момент добавлены в историю с помощью команды `git add`.

Комбинация параметров создает коммит всех проиндексированных изменений и добавляет к коммиту подставленный комментарий:

```bash
git commit -am "commit message"
```

### 5.4. Команда git diff

Чтобы посмотреть все неподтвержденные изменения, внесенные после последнего коммита, необходимо в терминале ввести команду:

```bash
git diff
```

В результате будет выведена служебная информация, позволяющая проанализировать изменения перед коммитом:

```diff
$ git diff
diff --git a/Git_Instruction.md b/Git_Instruction.md
index f1407f6..708e01b 100644
--- a/Git_Instruction.md
+++ b/Git_Instruction.md
@@ -33,4 +33,79 @@ git init <project_folder>

 В этом случае инициализация репозитория произойдёт в указанной папке.

+## 5. Запись изменений в репозиторий
+### 5.1. Команда git status
+Команда `git status` отображает состояние рабочего каталога и раздела проиндексированных файлов. С ее помощью можно проверить индексацию изменений и увидеть файлы, 
которые не отслеживаются Git.
```

## 6. Просмотр истории коммитов

Чтобы посмотреть список всех коммитов, в терминале надо ввести команду:

```bash
git log
```

Вывод команды может быть слишком громоздким:

```bash
$ git log
commit f8e5e59cc7affeaf24418af939431228cfd4c1be (HEAD -> master)
Author: asergeev <asergeev.me@yandex.ru>
Date:   Thu Dec 8 09:15:39 2022 +0300

    Добавление раздела 5

commit 05433b54f89142b8b89eece85c31a5d88d82391f
Author: asergeev <asergeev.me@yandex.ru>
Date:   Thu Dec 8 09:05:42 2022 +0300

    Удаление файла NewFile.txt
```

Для сокращения вывода необходимо добавить параметр `--oneline`:

```bash
git log --oneline
```

Тогда будет выведен однострочный список коммитов, содержащий идентификатор коммита и первую строка комментария к нему:

```bash
$ git log --oneline
f8e5e59 (HEAD -> master) Добавление раздела 5
05433b5 Удаление файла NewFile.txt
480a789 Добавление файла NewFile.txt
359c6d2 Добавление раздела 4
fd90565 Добавили подзаголовок 4
2b9c8d4 Добавили раздел 3
97d5335 Добавили раздел 2
6a16ece Добавили раздел 1
```

Команду `git log` часто используют вместе с другими командами. Обычно найденный коммит передают другому инструменту (например, `git checkout`), позволяющему воздействовать на историю коммитов.

## 7. Перемещение между сохранениями

После того как нашли ссылку на нужный коммит в истории:

```bash
$ git log --oneline
c5fc93c (HEAD -> master) Добавление раздела 6
f8e5e59 Добавление раздела 5
05433b5 Удаление файла NewFile.txt
480a789 Добавление файла NewFile.txt
359c6d2 Добавление раздела 4
fd90565 Добавили подзаголовок 4
2b9c8d4 Добавили раздел 3
97d5335 Добавили раздел 2
6a16ece Добавили раздел 1
```

для перехода к нему можно использовать команду `git checkout`:

```bash
git checkout 359c6d2
```

Может случиться ситуация, что будет выведено сообщение об ошибке:

```bash
error: Your local changes to the following files would be overwritten by checkout:
        Git_Instruction.md
Please commit your changes or stash them before you switch branches.
Aborting
```

Это значит, что есть не утверждённые изменения, и необходимо сделать коммит, либо спрятать изменения (stash).

При стандартном процессе разработки указатель HEAD обычно указывает на главную ветку master или другую локальную ветку. Но при переключении на предыдущий коммит HEAD указывает уже не на ветку, а непосредственно на сам коммит:

```bash
$ git checkout 359c6d2
Note: switching to '359c6d2'.

You are in 'detached HEAD' state. You can look around, make experimental
...

$ git log --oneline
359c6d2 (HEAD) Добавление раздела 4
fd90565 Добавили подзаголовок 4
2b9c8d4 Добавили раздел 3
97d5335 Добавили раздел 2
6a16ece Добавили раздел 1
```

Это приведет к тому, что рабочий каталог будет в точности соответствовать состоянию коммита 359c6d2. Можно просматривать файлы, компилировать проект, запускать тесты и даже редактировать файлы, не боясь потерять текущее состояние проекта. Никакие внесенные здесь изменения не будут сохранены в репозитории. Чтобы продолжить разработку, необходимо вернуться к текущему состоянию проекта:

```bash
$ git checkout master
Previous HEAD position was 359c6d2 Добавление раздела 4
Switched to branch 'master'
```

## 8. Игнорирование файлов

Не все файлы в проекте должны отслеживаться Git. Временные файлы из среды разработки, выходные данные тестов и журналы — это все примеры файлов, которые, вероятно, не нужно отслеживать. Для файлов, которые не отслеживаются Git, можно использовать `.gitignore` файл. Для файлов, отслеживаемых Git, можно сообщить Git прекратить их отслеживание и игнорировать изменения.

![logo](logo@2x.png)

Для примера добавим изображение в инструкцию. Для этого в папку проекта добавим файл изображения (в данном случае logo@2x.png), а в самой инструкции в месте, где необходимо вставить изображение, вставим:

```bash
![logo](logo@2x.png)
```

Однако, такого типа файлы обычно не отслеживаются в Git. Тогда их необходимо игнорировать. Для этого добавим его в `.gitignore`.

В связи с тем, что таких файлов может быть много, удобней использовать шаблоны. Например, `*.png`.

Сам файл `.gitignore` является отслеживаемым в проекте Git. Следовательно его необходимо добавить:

```bash
git add .gitignore
```

и затем закоммитить изменения:

```bash
git commit -m "Добавление .gitignore"
```

## 9. Работа с ветками

Ветка представляет собой отдельное направление разработки. Ветки выступают в качестве абстрактного представления для процесса редактирования/индексации/коммита. Можно рассматривать их как способ запросить новый рабочий каталог, раздел проиндексированных файлов и историю проекта. Новые коммиты записываются в историю текущей ветки, что приводит к образованию развилки в истории проекта.

### 9.1. Создание веток

Чтобы создать новую ветку, необходимо в терминале выполнить команду:

```bash
git branch <new-branch>
```

Затем для работы в новой ветке необходимо перейти в неё, используя команду:

```bash
git checkout <new-branch>
```

Эти команды можно объединить. Так, для того, чтобы создать новую ветку и сразу перейти в неё, необходимо в терминале выполнить команду:

```bash
git checkout -b <new-branch>
```

### 9.2. Удаление веток

Для удаления ветки надо выполнить команду в терминале:

```bash
git branch -d <branch>
```

В этом случае возможна ошибка, если не было проведено слияние веток:

```bash
$ git branch -d delete-branch
error: The branch 'delete-branch' is not fully merged.
If you are sure you want to delete it, run 'git branch -D delete-branch'.
```

Если необходимо удалить ветку в любом случае, тогда параметр будет таким:

```bash
git branch -D <branch>
```

### 9.3. Переключение между ветками

Команда `git checkout` позволяет перемещаться между ветками, созданными командой `git branch`. При переключении ветки происходит обновление файлов в рабочем каталоге в соответствии с версией, хранящейся в этой ветке, а Git начинает записывать все новые коммиты в этой ветке.

Для вывода списка всех веток в терминале надо выполнить команду:

```bash
git branch
```

Затем для перехода в необходимую ветку выполняем команду:

```bash
git checkout <branch>
```

### 9.4. Слияние веток

Слияние используется в Git, чтобы собрать воедино разветвленную историю. Команда `git merge` выполняет слияние отдельных направлений разработки, созданных с помощью команды `git branch`, в единую ветку.

При этом команды выполняют слияние в текущую ветку, в то время как целевая ветка остается без изменений. Поэтому команда `git merge` часто используется в сочетании с командами `git checkout` (для выбора текущей ветки) и `git branch -d` (для удаления устаревшей целевой ветки).

Таким образом, сначала в рабочей ветке выполняем коммит:

```bash
git commit -am "Комментарий"
```

затем переходим в ветку, куда будем объединяться:

```bash
git checkout <целевая ветка>
```

и объединяем ветку, которую хотим:

```bash
git merge <branch>
```

### 9.5. Разрешение конфликтов

В случае работы над одними файлами в разных ветках есть вероятность того, что при слиянии выйдет ошибка:

```bash
$ git merge checkout-branch
error: Your local changes to the following files would be overwritten by merge:
        Git_Instruction.md
Please commit your changes or stash them before you merge.
Aborting
Merge with strategy ort failed.
```

либо

```bash
$ git merge checkout-branch
error: Merging is not possible because you have unmerged files.
hint: Fix them up in the work tree, and then use 'git add/rm <file>'
hint: as appropriate to mark resolution and make a commit.
fatal: Exiting because of an unresolved conflict.
```

а в среде разработки (в данном случае Visual Code) предлагается исправить конфликт:
![confilct](conflict.png)
В этом случае необходимо сделать выбор.

## 10. Работа с удалёнными репозиториями

**Удаленный (иногда говорят "внешний") репозиторий** – это версии проекта, сохраненные на удаленном сервере. Доступ к репозиторию на таком сервере может осуществляться по интернету или по локальной сети.

Удаленный репозиторий – полноценный репозиторий, ничем не отличающийся от локального. У удаленного репозитория есть собственные ветки, собственный указатель HEAD, своя история коммитов и так далее.

Выгрузим текущий локальный репозиторий на GitHub.

### 10.1. Добавление удаленного репозитория к существующему локальному

Чтобы добавить удалённый репозиторий к локальному, надо его предварительно создать:
![remote](remote_1.png)
Укажем необходимы параметры:

* Public - чтобы к нему могли подключаться другие пользователи
* Файлы README и .gitignore добавлять не будем - из локального перенесём

![remote](remote_2.png)

После создания будет предложено несколько вариантов дальнейших действий:

![remote](remote_3.png)

Подключим удалённый репозиторий к существующему локальному:

```bash
git remote add origin https://github.com/asergeev79/Git_Lessons.git
git branch -M main
git push -u origin main 
```

Чтобы отключить удаленный репозиторий с именем origin

```bash
git remote remove origin
```

### 10.2. Просмотр всех удаленных репозиториев

Посмотрим список всех подключенных удаленных репозиториев и получим информацию о каждом из них. Для этого используется команда `git remote show`

```bash
 MINGW64 ~/Documents/GeekBrains/Git (main)
$ git remote show
origin

 MINGW64 ~/Documents/GeekBrains/Git (main)
$ git remote show origin
* remote origin
  Fetch URL: https://github.com/asergeev79/Git_Lessons.git
  Push  URL: https://github.com/asergeev79/Git_Lessons.git
  HEAD branch: main
  Remote branch:
    main tracked
  Local branch configured for 'git pull':
    main merges with remote main
  Local ref configured for 'git push':
    main pushes to main (up to date)
```

Таким образом можно просмотреть информацию о каждом из подключенных удаленных репозиториев.

### 10.3. Клонирование удаленного репозитория

Теперь, когда мы разобрались с настройкой подключения удаленного репозитория к уже существующему, давайте узнаем, как можно склонировать удаленный репозиторий к себе на компьютер. Операция клонирования создаёт на вашем компьютере точную копию удаленного репозитория.

Необходимость клонировать существующий удаленный репозиторий возникает в ситуациях, когда вы решаете поработать над уже существующим кодом. Для выполнения этой операции в Git предусмотрена команда `git clone`.

Склонируем себе репозиторий Examples:

```bash
git clone https://github.com/asergeev79/Examples.git
```

Ссылку на удаленный репозиторий можно получить, нажав на зеленую кнопку Code на главной странице репозитория на GitHub.

![remote](remote_4.png)

При выполнении команды `git clone https://github.com/asergeev79/Examples.git` произойдет следующее:

* В директории, откуда вы запустили команду git clone, создается директория с именем репозитория.
* В созданную директорию копируется репозиторий, все его ветки и коммиты.
* В новосозданный локальный репозиторий добавляется удаленный репозиторий с именем origin и ссылкой, которую мы передавали в git clone. Это избавляет нас от необходимости вручную писать git remote add origin `git clone https://github.com/asergeev79/Examples.git`. На этом процесс клонирования заканчивается.

### 10.4. Получение изменений из удаленного репозитория

Теперь, когда мы научились подключать удаленный репозиторий к локальному и клонировать его к себе на компьютер, пора узнать, как же получить изменения из удаленного репозитория.

У вас может возникнуть вопрос: зачем получать изменения, если только я загружаю их в свой удаленный репозиторий? Все верно, если вы работаете один, то вряд ли вам пригодится загружать изменения из удаленного репозитория в локальный. Но если вы работаете в команде, вы будете по несколько раз в день обновлять свой репозиторий, загружая в него коммиты, сделанные другими разработчиками из вашей команды.

Итак, чтобы получить изменения из удаленного репозитория, в Git предусмотрена команда `git fetch`.

```bash
$ git fetch origin
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), 694 bytes | 40.00 KiB/s, done.
From https://github.com/asergeev79/Examples
   27706f2..83ffbe0  main       -> origin/main
```

Здесь мы добавили в удалённый репозиторий файл README.md

Но изменений сейчас не увидим. На самом деле, файл тоже появился, просто рабочая копия не была обновлена. Это видно и из истории репозитория: у нас есть две отдельные ветки: main и origin/main. Причем указатель HEAD, который, как мы помним, отвечает за состояние рабочей копии, находится на ветке main.

```bash
$ git checkout origin/main
Note: switching to 'origin/main'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.
...
$ git checkout main
Previous HEAD position was 83ffbe0 Create README.md
Switched to branch 'main'
Your branch is behind 'origin/main' by 1 commit, and can be fast-forwarded.
  (use "git pull" to update your local branch)
```

Команда `git fetch` используется для синхронизации локальных ссылочных объектов с этими же объектами в удаленном репозитории. Рабочую копию она не меняет.
Чтобы синхронизировать локальную рабочую копию с удаленным репозиторием, нужно слить удаленные ветки в локальные. Сделать это можно уже знакомой командой `git merge`.

```bash
$ git merge origin/main
Updating 27706f2..83ffbe0
Fast-forward
 README.md | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
```

Связкой `git fetch && git merge` мы получили изменения из удаленного репозитория и обновили свою рабочую копию. Часто вместо этого хочется получать изменения и сразу обновлять рабочую копию так, чтобы она соответствовала удаленному репозиторию. И для этого в Git существует отдельная команда. Называется она `git pull`.

```bash
$ git pull origin
Already up to date.
```

### 10.5. Отправка изменений в удаленный репозиторий

Осталось изучить, как загружать в него свои локальные изменения. Для этого в Git существует команда `git push`.

```bash
$ git push origin main
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 4 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 3.51 KiB | 1.17 MiB/s, done.
Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To https://github.com/asergeev79/Git_Lessons.git
   0391603..f53a320  main -> main
```

По факту данная команда аналогична связке `git fetch + git merge`, но выполненной из удаленного репозитория (это просто аналогия, на самом деле так сделать не получится).

Если изменения с нашей ветки можно слить с удаленной веткой в режиме fast-forward, то есть на удаленной ветке нет коммитов сделанных после наших, то все пройдет нормально.

Если на удаленной ветке есть коммиты, которые были сделаны позже наших, то есть слияние в режиме fast-forward выполнить невозможно, то команда завершится с ошибкой. Ведь в этом случае есть угроза перезаписи истории удаленного репозитория и удаления всех коммитов, созданных позже наших.

Но если вы вдруг передали флаг `--force`, то все коммиты, которых нет в вашем локальном репозитории, будут удалены. То есть удаленный репозиторий станет точной копией вашего локального. Есть более щадящая версия этого флага `– --force-with-lease`. Он будет делать в точности то же самое, но если вдруг нужно будет удалить коммит, созданный не вами, выполнение немедленно прекратится и вернется ошибка. Таким образом, вы не попадете в ситуацию, когда вы случайно удалили чужой коммит.

### 10.6. Работа с репозиторием, создание форков и пулл-реквестов

Одной из самых важных частей GitHub является создание форков.

**Форк (от англ. fork – вилка)** – точная копия репозитория, но в вашем аккаунте. Форки нужны, чтобы вносить свои изменения в проект, к репозиторию которого у вас нет прямого доступа.

**Пулл-реквест (от англ. pull-request – запрос pull)** – функция GitHub, позволяющая попросить владельца репозитория, от которого мы сделали форк, загрузить наши изменения обратно в свой репозиторий.

Если коротко, форки и пулл-реквесты нужны, чтобы любой пользователь мог внести свой вклад в любой открытый проект, репозиторий которого есть на GitHub. Кроме того, перед тем как влить ваши изменения в основной репозиторий, ответственные обязательно проверят ваш код на наличие ошибок и уязвимостей. Таким образом, даже если ваши изменения не примут, вы получите первоклассный code-review с указанием всех неточностей.

* Для начала зайдем на страницу репозитория проекта <https://github.com/ignat-sergeev/SCV_Git_0812-10.git>. Нажимаем на кнопку Fork, как показано на картинке. После этого Git создаст точную копию этого репозитория в вашем аккаунте.

![remote](remote_5.png)

![remote](remote_6.png)

* Клонируем репозиторий к себе на компьютер командой `git clone`. Создадим файл README.md с описанием проекта, чтобы другим пользователям было понятно, в чем отличие этой реализации от остальных.